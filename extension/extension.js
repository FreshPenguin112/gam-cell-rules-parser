// data:text/javascript;base64,bGV0IG1vZHVsZSA9IHt9CmNvbnN0IGFjdGlvbnMgPSAvKC4+KSguKikvZwpjb25zdCBzdHJpbmcgPSAvXCIoLiopXCIvZwpjb25zdCB0cmlnZXJzID0gLyguOikoLiopL2cKY29uc3QgZGF0YSA9IC8oXD8uKSguKikvZwpjb25zdCBmdW5jdGlvblJ1bm5lciA9IC9cJFwoKC4qKVwpKC4qKS9nCmNvbnN0IGZ1bmN0aW9uUmVnZXggPSAvKC4qKVwkPVwoKC4qKVwpeyguKil9L2cKY29uc3QgdmFyaWFibGUgPSAvKC4qKVw9KC4qKS9nCmNvbnN0IHZhcmlhYmxlR2V0dGVyID0gL0AoLiopL2cKY29uc3QgaWZlbHNlID0gLyguKilcPyguKilcfCguKikvZwoKY29uc3Qgc2luZ2xlcyA9IHsKICAgICchcyc6IHsgdHlwZTogJ3N0b3AnIH0sCiAgICAiL2wiOiB7IHR5cGU6ICdsZWZ0IGRpcmVjdGlvbicgfSwKICAgICIvciI6IHsgdHlwZTogJ3JpZ2h0IGRpcmVjdGlvbicgfSwKICAgICIvdSI6IHsgdHlwZTogJ3VwIGRpcmVjdGlvbicgfSwKICAgICIvZCI6IHsgdHlwZTogJ2Rvd24gZGlyZWN0aW9uJyB9LAogICAgIi9tIjogeyB0eXBlOiAndHJpZ2VyIGRpcmVjdGlvbicgfSwKICAgICIvYyI6IHsgdHlwZTogJ2Nsb2Nrd2lzZSByb3RhdGlvbicgfSwKICAgICIvdyI6IHsgdHlwZTogJ2NvdW50ZXItY2xvY2t3aXNlIHJvdGF0aW9uJyB9LAogICAgIm5hIjogeyB0eXBlOiAnbm9wJyB9Cn0KY29uc3QgdHJpZ2VyTmFtZXMgPSB7CiAgICAibDoiOiAicHVzaExlZnQiLAogICAgInI6IjogInB1c2hSaWdodCIsCiAgICAidToiOiAicHVzaFVwIiwKICAgICJkOiI6ICJwdXNoRG93biIsCiAgICAiYToiOiAicHVzaEFueXdoZXJlIiwKICAgICJjOiI6ICJyb3RhdGVkIiwKICAgICJ0OiI6ICJ0aWNrIiwKfQpjb25zdCBjb21tYW5kVmFsdWVzID0gewogICAgJ2xlZnQgZGlyZWN0aW9uJzogZnVuY3Rpb24oY29tLCByZXQpIHsgcmV0dXJuIDMgfSwKICAgICdyaWdodCBkaXJlY3Rpb24nOiBmdW5jdGlvbihjb20sIHJldCkgeyByZXR1cm4gMSB9LAogICAgJ3VwIGRpcmVjdGlvbic6IGZ1bmN0aW9uKGNvbSwgcmV0KSB7IHJldHVybiAwIH0sCiAgICAnZG93biBkaXJlY3Rpb24nOiBmdW5jdGlvbihjb20sIHJldCkgeyByZXR1cm4gMiB9LAogICAgJ3N0cmluZy9udW1iZXInOiBmdW5jdGlvbihjb20sIHJldCkgeyByZXR1cm4gY29tLnZhbHVlIH0sCiAgICAndmFyaWFibGUgdmFsdWUgZ2V0dGVyJzogZnVuY3Rpb24oY29tLCByZXQpIHsgcmV0dXJuIHJldFtjb20ubmFtZV0gfQp9Cgpjb25zdCBwYXJzZUNvbW1hbmQgPSAoY29tKSA9PiB7CiAgICBjb25zb2xlLmxvZyhjb20pCiAgICBpZiAoZnVuY3Rpb25SZWdleC50ZXN0KGNvbSkpIHsKICAgICAgICBjb25zdCBjb21tYW5kID0gY29tLnNwbGl0KGZ1bmN0aW9uUmVnZXgpCiAgICAgICAgcmV0dXJuIHsKICAgICAgICAgICAgdHlwZTogJ2Z1bmN0aW9uIGRlZmluaXRpb24nLAogICAgICAgICAgICBuYW1lOiBjb21tYW5kWzFdLAogICAgICAgICAgICBpbnB1dHM6IGNvbW1hbmRbMl0ucmVwbGFjZUFsbCgvXFwsL2csICc8Q09NTUE+Jykuc3BsaXQoJywnKS5tYXAoeCA9PiB4LnJlcGxhY2VBbGwoJzxDT01NQT4nLCAnLCcpKSwKICAgICAgICAgICAgY29kZTogY29tbWFuZFszXS5yZXBsYWNlQWxsKC9cXCwvZywgJzxDT01NQT4nKS5zcGxpdCgnLCcpLm1hcCh4ID0+IHgucmVwbGFjZUFsbCgnPENPTU1BPicsICcsJykpLm1hcChwYXJzZUNvbW1hbmQpCiAgICAgICAgfQogICAgfQoKICAgIGlmICh0cmlnZXJzLnRlc3QoY29tKSkgewogICAgICAgIGNvbnN0IGNvbW1hbmQgPSBjb20uc3BsaXQodHJpZ2VycykKICAgICAgICBjb25zdCBpbnB1dCA9IHBhcnNlQ29tbWFuZChjb21tYW5kWzJdKQogICAgICAgIGlucHV0LmdldCA9IHRydWUKICAgICAgICByZXR1cm4gewogICAgICAgICAgICB0eXBlOiAndHJpZ2VyJywKICAgICAgICAgICAgdmFyaWFudDogY29tbWFuZFsxXSwKICAgICAgICAgICAgZnVuYzogaW5wdXQKICAgICAgICB9CiAgICB9CiAgICAKICAgIGlmIChmdW5jdGlvblJ1bm5lci50ZXN0KGNvbSkpIHsKICAgICAgICBjb25zdCBjb21tYW5kID0gY29tLnNwbGl0KGZ1bmN0aW9uUnVubmVyKQogICAgICAgIHJldHVybiB7CiAgICAgICAgICAgIHR5cGU6ICdmdW5jdGlvbiBydW5uZXInLAogICAgICAgICAgICBuYW1lOiBjb21tYW5kWzJdLAogICAgICAgICAgICBpbnB1dHM6IGNvbW1hbmRbMV0ucmVwbGFjZUFsbCgvXFwsL2csICc8Q09NTUE+Jykuc3BsaXQoJywnKS5tYXAoeCA9PiB4LnJlcGxhY2VBbGwoJzxDT01NQT4nLCAnLCcpKS5tYXAocGFyc2VDb21tYW5kKQogICAgICAgIH0KICAgIH0KICAgIAogICAgaWYgKHZhcmlhYmxlLnRlc3QoY29tKSkgewogICAgICAgIGNvbnN0IGNvbW1hbmQgPSBjb20uc3BsaXQodmFyaWFibGUpCiAgICAgICAgY29uc3QgaW5wdXQgPSBwYXJzZUNvbW1hbmQoY29tbWFuZFsyXSkKICAgICAgICBpbnB1dC5nZXQgPSB0cnVlCiAgICAgICAgcmV0dXJuIHsKICAgICAgICAgICAgdHlwZTogJ3ZhcmlhYmxlIGRlZmluaXRpb24nLAogICAgICAgICAgICBuYW1lOiBjb21tYW5kWzFdLAogICAgICAgICAgICB2YWx1ZTogaW5wdXQKICAgICAgICB9CiAgICB9CiAgICAKICAgIGlmICh2YXJpYWJsZUdldHRlci50ZXN0KGNvbSkpIHsKICAgICAgICBjb25zdCBjb21tYW5kID0gY29tLnNwbGl0KHZhcmlhYmxlR2V0dGVyKQogICAgICAgIHJldHVybiB7CiAgICAgICAgICAgIHR5cGU6ICd2YXJpYWJsZSB2YWx1ZSBnZXR0ZXInLAogICAgICAgICAgICBuYW1lOiBjb21tYW5kWzFdCiAgICAgICAgfQogICAgfQogICAgCiAgICBpZiAoaWZlbHNlLnRlc3QoY29tKSkgewogICAgICAgIGNvbnN0IGNvbW1hbmQgPSBjb20uc3BsaXQoaWZlbHNlKQogICAgICAgIGNvbnN0IGlucHV0MSA9IHBhcnNlQ29tbWFuZChjb21tYW5kWzFdKQogICAgICAgIGlucHV0MS5nZXQgPSB0cnVlCiAgICAgICAgY29uc3QgaW5wdXQyID0gcGFyc2VDb21tYW5kKGNvbW1hbmRbMl0pCiAgICAgICAgaW5wdXQyLmdldCA9IHRydWUKICAgICAgICBjb25zdCBpbnB1dDMgPSBwYXJzZUNvbW1hbmQoY29tbWFuZFszXSkKICAgICAgICBpbnB1dDMuZ2V0ID0gdHJ1ZQogICAgICAgIHJldHVybiB7CiAgICAgICAgICAgIHR5cGU6ICdpZiBlbHNlJywKICAgICAgICAgICAgbmFtZTogaW5wdXQxLAogICAgICAgICAgICB0cnVlOiBpbnB1dDIsCiAgICAgICAgICAgIGZhbHNlOiBpbnB1dDMKICAgICAgICB9CiAgICB9CgogICAgaWYgKGFjdGlvbnMudGVzdChjb20pKSB7CiAgICAgICAgY29uc3QgY29tbWFuZCA9IGNvbS5zcGxpdChhY3Rpb25zKQogICAgICAgIGNvbnN0IGlucHV0ID0gcGFyc2VDb21tYW5kKGNvbW1hbmRbMl0pCiAgICAgICAgaW5wdXQuZ2V0ID0gdHJ1ZQogICAgICAgIHJldHVybiB7CiAgICAgICAgICAgIHR5cGU6ICdhY3Rpb24nLAogICAgICAgICAgICB2YXJpYW50OiBjb21tYW5kWzFdLAogICAgICAgICAgICBpbnB1dDogaW5wdXQKICAgICAgICB9CiAgICB9CiAgICAKICAgIGlmIChkYXRhLnRlc3QoY29tKSkgewogICAgICAgIGNvbnN0IGNvbW1hbmQgPSBjb20uc3BsaXQoZGF0YSkKICAgICAgICBjb25zdCBpbnB1dCA9IHBhcnNlQ29tbWFuZChjb21tYW5kWzJdKQogICAgICAgIGlucHV0LmdldCA9IHRydWUKICAgICAgICByZXR1cm4gewogICAgICAgICAgICB0eXBlOiAnZGF0YSByZWFkZXInLAogICAgICAgICAgICB2YXJpYW50OiBjb21tYW5kWzFdLAogICAgICAgICAgICBpbnB1dDogaW5wdXQKICAgICAgICB9CiAgICB9CiAgICAKICAgIGlmIChzdHJpbmcudGVzdChjb20pKSB7CiAgICAgICAgY29uc3QgY29tbWFuZCA9IGNvbS5zcGxpdChzdHJpbmcpCiAgICAgICAgcmV0dXJuIHsKICAgICAgICAgICAgdHlwZTogJ3N0cmluZy9udW1iZXInLAogICAgICAgICAgICB2YWx1ZTogY29tbWFuZFsxXSwKICAgICAgICB9CiAgICB9CiAgICAKICAgIHJldHVybiBzaW5nbGVzW2NvbV0gPyBzaW5nbGVzW2NvbV0gOiBPYmplY3QuYXNzaWduKHNpbmdsZXNbJ25hJ10sIHsgb3JpZ25hbDogY29tIH0pCn0KCmNvbnN0IHBhcnNlciA9IGZ1bmN0aW9uKHJ1bGUpIHsKICAgIHJ1bGUgPSBydWxlLnJlcGxhY2VBbGwoJ1xuJywgJycpCiAgICBsZXQgaW5zaWRlID0gZmFsc2UKICAgIGxldCBjb21tYW5kcyA9IFsnJ10KICAgIGZvciAobGV0IGlkeCA9IDAsIGNoYXIgPSAnJzsgaWR4IDwgcnVsZS5sZW5ndGggKyAxOyBjaGFyID0gcnVsZVtpZHgrK10pIHsKICAgICAgICBpZiAoY2hhciA9PT0gJywnICYmICFpbnNpZGUpIHsKICAgICAgICAgICAgY29tbWFuZHMucHVzaCgnJykKICAgICAgICAgICAgY29udGludWUKICAgICAgICB9CiAgICAgICAgY29tbWFuZHNbY29tbWFuZHMubGVuZ3RoLTFdICs9IGNoYXIKICAgICAgICBpZiAoY2hhciA9PT0gJyInIHx8IGNoYXIgPT09ICcoJyB8fCBjaGFyID09PSAneycpIHsKICAgICAgICAgICAgaW5zaWRlID0gdHJ1ZQogICAgICAgICAgICBjb250aW51ZQogICAgICAgIH0KICAgICAgICBpZiAoY2hhciA9PT0gJyInIHx8IGNoYXIgPT09ICcpJyB8fCBjaGFyID09PSAnfScpIHsKICAgICAgICAgICAgaW5zaWRlID0gZmFsc2UKICAgICAgICAgICAgY29udGludWUKICAgICAgICB9CiAgICB9CiAgICBsZXQgcmV0VmFsID0gewogICAgICAgIGVycm9yczogW10sCiAgICAgICAgdmFyczogewogICAgICAgICAgICBjZGlyOiAwLAogICAgICAgICAgICBjbmFtOiAnbm9uZScKICAgICAgICB9LAogICAgICAgIGZ1bmNzOiB7CiAgICAgICAgICAgIGltcDogewogICAgICAgICAgICAgICAgaW5wdXRzOiBbJ21vZHVsZSddLAogICAgICAgICAgICAgICAgY29tbWFuZHM6IFsKICAgICAgICAgICAgICAgICAgICB7IAogICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnY2FsbCcsIAogICAgICAgICAgICAgICAgICAgICAgICBmdW5jOiAnaW1wb3J0ZXInLCAKICAgICAgICAgICAgICAgICAgICAgICAgYXJnczogWwogICAgICAgICAgICAgICAgICAgICAgICAgICAgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICd2YXJpYWJsZSB2YWx1ZSBnZXR0ZXInLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6ICdtb2R1bGUnCiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICAgIF0gCiAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgXQogICAgICAgICAgICB9LAogICAgICAgICAgICBwb3M6IHsKICAgICAgICAgICAgICAgIGlucHV0czogWyd4JywgJ3knXSwKICAgICAgICAgICAgICAgIGNvbW1hbmRzOiBbCiAgICAgICAgICAgICAgICAgICAgewogICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnYWN0aW9uJywKICAgICAgICAgICAgICAgICAgICAgICAgdmFyaWFudDogJ3Q+JywKICAgICAgICAgICAgICAgICAgICAgICAgaW5wdXQ6IHsgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnY2FsbCcsIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgZnVuYzogJ3Bvc2l0aW9uIGNhbGxjdWxhdG9yJyAsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmdzOiBbCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAndmFyaWFibGUgdmFsdWUgZ2V0dGVyJywKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogJ3gnCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICd2YXJpYWJsZSB2YWx1ZSBnZXR0ZXInLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiAneScKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBdIAogICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgXQogICAgICAgICAgICB9LAogICAgICAgICAgICBjYWxsOiB7CiAgICAgICAgICAgICAgICBpbnB1dHM6IFsnZnVuY3Rpb24nXSwKICAgICAgICAgICAgICAgIGNvbW1hbmRzOiBbCiAgICAgICAgICAgICAgICAgICAgewogICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnYWN0aW9uJywKICAgICAgICAgICAgICAgICAgICAgICAgdmFyaWFudDogJ3Q+JywKICAgICAgICAgICAgICAgICAgICAgICAgaW5wdXQ6IHsgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnY2FsbCcsIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgZnVuYzogewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICd2YXJpYWJsZSB2YWx1ZSBnZXR0ZXInLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6ICdmdW5jdGlvbicKICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sCiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmdzOiBbCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAndmFyaWFibGUgdmFsdWUgZ2V0dGVyJywKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogJ1tmdW5jQXJnc10nCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICAgICAgXQogICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgXQogICAgICAgICAgICB9LAogICAgICAgICAgICBuZXdOZWlnaGJvcjogewogICAgICAgICAgICAgICAgaW5wdXRzOiBbJ2xvY2F0aW9uJywgJ3R5cGUnXSwKICAgICAgICAgICAgICAgIGNvbW1hbmRzOiBbCiAgICAgICAgICAgICAgICAgICAgeyAKICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2NhbGwnLCAKICAgICAgICAgICAgICAgICAgICAgICAgZnVuYzogJ2NyZWF0ZSBuZXcgbmVpZ2hib3InLAogICAgICAgICAgICAgICAgICAgICAgICBhcmdzOiBbCiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ3ZhcmlhYmxlIHZhbHVlIGdldHRlcicsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogJ2xvY2F0aW9uJwogICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwKICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAndmFyaWFibGUgdmFsdWUgZ2V0dGVyJywKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiAndHlwZScKICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgICAgXQogICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIF0KICAgICAgICAgICAgfQogICAgICAgIH0sCiAgICAgICAgaW1wb3J0czogW10sCiAgICAgICAgdHJpZ2VyczogewogICAgICAgICAgICB0aWNrOiBbXSwKICAgICAgICAgICAgcHVzaFVwOiBbXSwKICAgICAgICAgICAgcHVzaERvd246IFtdLAogICAgICAgICAgICBwdXNoTGVmdDogW10sCiAgICAgICAgICAgIHB1c2hSaWdodDogW10sCiAgICAgICAgICAgIHB1c2hBbnl3aGVyZTogW10sCiAgICAgICAgICAgIHJvdGF0ZWQ6IFtdCiAgICAgICAgfSwKICAgICAgICBjb21tYW5kczogW10KICAgIH0KICAgIHJldFZhbC5jb21tYW5kcyA9IGNvbW1hbmRzID0gY29tbWFuZHMubWFwKGNvbW1hbmQgPT4gewogICAgICAgIGNvbW1hbmQgPSBwYXJzZUNvbW1hbmQoY29tbWFuZCkKICAgICAgICBpZiAoY29tbWFuZC50eXBlID09PSAndHJpZ2VyJykgewogICAgICAgICAgICByZXRWYWwudHJpZ2Vyc1t0cmlnZXJOYW1lc1tjb21tYW5kLnZhcmlhbnRdXS5wdXNoKGNvbW1hbmQuZnVuYykKICAgICAgICB9CiAgICAgICAgaWYgKGNvbW1hbmQudHlwZSA9PT0gJ2Z1bmN0aW9uIGRlZmluaXRpb24nKSB7CiAgICAgICAgICAgIHJldFZhbC5mdW5jc1tjb21tYW5kLm5hbWVdID0gewogICAgICAgICAgICAgICAgaW5wdXRzOiBjb21tYW5kLmlucHV0cywKICAgICAgICAgICAgICAgIGNvbW1hbmRzOiBjb21tYW5kLmNvZGUKICAgICAgICAgICAgfQogICAgICAgIH0KICAgICAgICBpZiAoY29tbWFuZC50eXBlID09PSAndmFyaWFibGUgZGVmaW5pdGlvbicpIHsKICAgICAgICAgICAgaWYgKCFjb21tYW5kVmFsdWVzW2NvbW1hbmQudmFsdWUudHlwZV0pIHsKICAgICAgICAgICAgICAgIHJldFZhbC5lcnJvcnMucHVzaChgY2Fubm90IHNldCB0aGUgdmFsdWUgb2YgYSB2YXJpYWJsZSB0byBhIGNvbW1hbmQgd2l0aCBubyBkZWZhdWx0IHJldHVybiB2YWx1ZVxuY29tbWFuZDogJHtKU09OLnBhcnNlKGNvbW1hbmQpfVxudmFsdWUgdHlwZTogJHtjb21tYW5kLnZhbHVlLnR5cGV9YCkKICAgICAgICAgICAgICAgIHJldHVybiBzaW5nbGVzWyduYSddCiAgICAgICAgICAgIH0KICAgICAgICAgICAgcmV0VmFsLnZhcnNbY29tbWFuZC5uYW1lXSA9IGNvbW1hbmRWYWx1ZXNbY29tbWFuZC52YWx1ZS50eXBlXShjb21tYW5kLCByZXRWYWwpCiAgICAgICAgfQogICAgICAgIGlmIChjb21tYW5kLnR5cGUgPT09ICdub3AnICYmIGNvbW1hbmQub3JpZ25hbCAhPT0gbnVsbCkgcmV0VmFsLmVycm9ycy5wdXNoKGBpbnZhbGlkIGNvbW1hbmQvY29tbWFuZCBzdHJ1Y3R1cmU6ICR7Y29tbWFuZC5vcmlnbmFsfWApCiAgICAgICAgaWYgKGNvbW1hbmQudHlwZSA9PT0gJ2Z1bmN0aW9uIHJ1bm5lcicgJiYgY29tbWFuZC5uYW1lID09PSAnaW1wJykgewogICAgICAgICAgICByZXRWYWwuaW1wb3J0cy5wdXNoKGNvbW1hbmQuaW5wdXRzWzBdLnZhbHVlKQogICAgICAgIH0KICAgICAgICByZXR1cm4gY29tbWFuZAogICAgfSkKCiAgICByZXR1cm4gcmV0VmFsCn0KCm1vZHVsZS5leHBvcnRzID0gcGFyc2VyCgoKY2xhc3MgY2VsbFBhcnNlciB7DQogICAgY29uc3RydWN0b3IgKHJ1bnRpbWUpIHsNCiAgICAgICAgLy8gRXh0ZW5zaW9uIHN0dWZmDQogICAgICAgIHRoaXMucnVudGltZSA9IHJ1bnRpbWU7DQogICAgfQ0KDQogICAgZ2V0SW5mbyAoKSB7DQogICAgICAgIHJldHVybiB7DQogICAgICAgICAgICBpZDogJ2NlbGxwYXJzZXInLA0KICAgICAgICAgICAgbmFtZTogJ0dhbSBDZWxsIFJ1bGUgUGFyc2VyJywNCiAgICAgICAgICAgIGNvbG9yMTogJyNmZmJiMDAnLA0KICAgICAgICAgICAgY29sb3IyOiAnI2ZmYWEwMCcsDQogICAgICAgICAgICBibG9ja3M6IFsNCiAgICAgICAgICAgICAgICB7DQogICAgICAgICAgICAgICAgICAgIG9wY29kZTogJ3BhcnNldGV4dGNvZGVpbnRvanNvbicsDQogICAgICAgICAgICAgICAgICAgIGJsb2NrVHlwZTogInJlcG9ydGVyIiwNCiAgICAgICAgICAgICAgICAgICAgdGV4dDogInBhcnNlIHRleHQgY29kZSBbdGV4dF0gaW50byBqc29uIGRhdGEiLA0KICAgICAgICAgICAgICAgICAgICBhcmd1bWVudHM6IHsNCiAgICAgICAgICAgICAgICAgICAgICAgIHRleHQ6IHsNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAic3RyaW5nIiwNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0VmFsdWU6ICIkKFwicmVsYXRpdmUgbW92ZWFibGUgdmVydGljYWxseVwiKWltcCx0aWNrJD0oKXt1Pi91LC91fSx0OiQoKXRpY2siDQogICAgICAgICAgICAgICAgICAgICAgICB9DQogICAgICAgICAgICAgICAgICAgIH0NCiAgICAgICAgICAgICAgICB9DQogICAgICAgICAgICBdDQogICAgICAgIH07DQogICAgfTsNCiAgICANCiAgICAvLyBDb2RlIGZvciBibG9ja3MgZ28gaGVyZQ0KICAgIA0KICAgIHBhcnNldGV4dGNvZGVpbnRvanNvbih7dGV4dH0pIHsNCiAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHBhcnNlcih0ZXh0KSkNCiAgICB9DQp9Ow0KDQoNCg0KKGZ1bmN0aW9uKCkgew0KICAgIHZhciBleHRlbnNpb25DbGFzcyA9IGNlbGxQYXJzZXI7DQogICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICJ1bmRlZmluZWQiIHx8ICF3aW5kb3cudm0pIHsNCiAgICAgICAgU2NyYXRjaC5leHRlbnNpb25zLnJlZ2lzdGVyKG5ldyBleHRlbnNpb25DbGFzcygpKTsNCiAgICB9IGVsc2Ugew0KICAgICAgICB2YXIgZXh0ZW5zaW9uSW5zdGFuY2UgPSBuZXcgZXh0ZW5zaW9uQ2xhc3Mod2luZG93LnZtLmV4dGVuc2lvbk1hbmFnZXIucnVudGltZSk7DQogICAgICAgIHZhciBzZXJ2aWNlTmFtZSA9IHdpbmRvdy52bS5leHRlbnNpb25NYW5hZ2VyLl9yZWdpc3RlckludGVybmFsRXh0ZW5zaW9uKGV4dGVuc2lvbkluc3RhbmNlKTsNCiAgICAgICAgd2luZG93LnZtLmV4dGVuc2lvbk1hbmFnZXIuX2xvYWRlZEV4dGVuc2lvbnMuc2V0KGV4dGVuc2lvbkluc3RhbmNlLmdldEluZm8oKS5pZCwgc2VydmljZU5hbWUpOw0KICAgIH07DQp9KSgp

let module = {}
const actions = /(.>)(.*)/g
const string = /\"(.*)\"/g
const trigers = /(.:)(.*)/g
const data = /(\?.)(.*)/g
const functionRunner = /\$\((.*)\)(.*)/g
const functionRegex = /(.*)\$=\((.*)\){(.*)}/g
const variable = /(.*)\=(.*)/g
const variableGetter = /@(.*)/g
const ifelse = /(.*)\?(.*)\|(.*)/g

const singles = {
    '!s': { type: 'stop' },
    "/l": { type: 'left direction' },
    "/r": { type: 'right direction' },
    "/u": { type: 'up direction' },
    "/d": { type: 'down direction' },
    "/m": { type: 'triger direction' },
    "/c": { type: 'clockwise rotation' },
    "/w": { type: 'counter-clockwise rotation' },
    "na": { type: 'nop' }
}
const trigerNames = {
    "l:": "pushLeft",
    "r:": "pushRight",
    "u:": "pushUp",
    "d:": "pushDown",
    "a:": "pushAnywhere",
    "c:": "rotated",
    "t:": "tick",
}
const commandValues = {
    'left direction': function(com, ret) { return 3 },
    'right direction': function(com, ret) { return 1 },
    'up direction': function(com, ret) { return 0 },
    'down direction': function(com, ret) { return 2 },
    'string/number': function(com, ret) { return com.value },
    'variable value getter': function(com, ret) { return ret[com.name] }
}

const parseCommand = (com) => {
    console.log(com)
    if (functionRegex.test(com)) {
        const command = com.split(functionRegex)
        return {
            type: 'function definition',
            name: command[1],
            inputs: command[2].replaceAll(/\\,/g, '<COMMA>').split(',').map(x => x.replaceAll('<COMMA>', ',')),
            code: command[3].replaceAll(/\\,/g, '<COMMA>').split(',').map(x => x.replaceAll('<COMMA>', ',')).map(parseCommand)
        }
    }

    if (trigers.test(com)) {
        const command = com.split(trigers)
        const input = parseCommand(command[2])
        input.get = true
        return {
            type: 'triger',
            variant: command[1],
            func: input
        }
    }
    
    if (functionRunner.test(com)) {
        const command = com.split(functionRunner)
        return {
            type: 'function runner',
            name: command[2],
            inputs: command[1].replaceAll(/\\,/g, '<COMMA>').split(',').map(x => x.replaceAll('<COMMA>', ',')).map(parseCommand)
        }
    }
    
    if (variable.test(com)) {
        const command = com.split(variable)
        const input = parseCommand(command[2])
        input.get = true
        return {
            type: 'variable definition',
            name: command[1],
            value: input
        }
    }
    
    if (variableGetter.test(com)) {
        const command = com.split(variableGetter)
        return {
            type: 'variable value getter',
            name: command[1]
        }
    }
    
    if (ifelse.test(com)) {
        const command = com.split(ifelse)
        const input1 = parseCommand(command[1])
        input1.get = true
        const input2 = parseCommand(command[2])
        input2.get = true
        const input3 = parseCommand(command[3])
        input3.get = true
        return {
            type: 'if else',
            name: input1,
            true: input2,
            false: input3
        }
    }

    if (actions.test(com)) {
        const command = com.split(actions)
        const input = parseCommand(command[2])
        input.get = true
        return {
            type: 'action',
            variant: command[1],
            input: input
        }
    }
    
    if (data.test(com)) {
        const command = com.split(data)
        const input = parseCommand(command[2])
        input.get = true
        return {
            type: 'data reader',
            variant: command[1],
            input: input
        }
    }
    
    if (string.test(com)) {
        const command = com.split(string)
        return {
            type: 'string/number',
            value: command[1],
        }
    }
    
    return singles[com] ? singles[com] : Object.assign(singles['na'], { orignal: com })
}

const parser = function(rule) {
    rule = rule.replaceAll('\n', '')
    let inside = false
    let commands = ['']
    for (let idx = 0, char = ''; idx < rule.length + 1; char = rule[idx++]) {
        if (char === ',' && !inside) {
            commands.push('')
            continue
        }
        commands[commands.length-1] += char
        if (char === '"' || char === '(' || char === '{') {
            inside = true
            continue
        }
        if (char === '"' || char === ')' || char === '}') {
            inside = false
            continue
        }
    }
    let retVal = {
        errors: [],
        vars: {
            cdir: 0,
            cnam: 'none'
        },
        funcs: {
            imp: {
                inputs: ['module'],
                commands: [
                    { 
                        type: 'call', 
                        func: 'importer', 
                        args: [
                            {
                                type: 'variable value getter',
                                name: 'module'
                            }
                        ] 
                    }
                ]
            },
            pos: {
                inputs: ['x', 'y'],
                commands: [
                    {
                        type: 'action',
                        variant: 't>',
                        input: { 
                            type: 'call', 
                            func: 'position callculator' ,
                            args: [
                                {
                                    type: 'variable value getter',
                                    name: 'x'
                                },
                                {
                                    type: 'variable value getter',
                                    name: 'y'
                                }
                            ] 
                        }
                    }
                ]
            },
            call: {
                inputs: ['function'],
                commands: [
                    {
                        type: 'action',
                        variant: 't>',
                        input: { 
                            type: 'call', 
                            func: {
                                type: 'variable value getter',
                                name: 'function'
                            },
                            args: [
                                {
                                    type: 'variable value getter',
                                    name: '[funcArgs]'
                                }
                            ]
                        }
                    }
                ]
            },
            newNeighbor: {
                inputs: ['location', 'type'],
                commands: [
                    { 
                        type: 'call', 
                        func: 'create new neighbor',
                        args: [
                            {
                                type: 'variable value getter',
                                name: 'location'
                            },
                            {
                                type: 'variable value getter',
                                name: 'type'
                            }
                        ]
                    }
                ]
            }
        },
        imports: [],
        trigers: {
            tick: [],
            pushUp: [],
            pushDown: [],
            pushLeft: [],
            pushRight: [],
            pushAnywhere: [],
            rotated: []
        },
        commands: []
    }
    retVal.commands = commands = commands.map(command => {
        command = parseCommand(command)
        if (command.type === 'triger') {
            retVal.trigers[trigerNames[command.variant]].push(command.func)
        }
        if (command.type === 'function definition') {
            retVal.funcs[command.name] = {
                inputs: command.inputs,
                commands: command.code
            }
        }
        if (command.type === 'variable definition') {
            if (!commandValues[command.value.type]) {
                retVal.errors.push(`cannot set the value of a variable to a command with no default return value\ncommand: ${JSON.parse(command)}\nvalue type: ${command.value.type}`)
                return singles['na']
            }
            retVal.vars[command.name] = commandValues[command.value.type](command, retVal)
        }
        if (command.type === 'nop' && command.orignal !== null) retVal.errors.push(`invalid command/command structure: ${command.orignal}`)
        if (command.type === 'function runner' && command.name === 'imp') {
            retVal.imports.push(command.inputs[0].value)
        }
        return command
    })

    return retVal
}

module.exports = parser


class cellParser {
    constructor (runtime) {
        // Extension stuff
        this.runtime = runtime;
    }

    getInfo () {
        return {
            id: 'cellparser',
            name: 'Gam Cell Rule Parser',
            color1: '#ffbb00',
            color2: '#ffaa00',
            blocks: [
                {
                    opcode: 'parsetextcodeintojson',
                    blockType: "reporter",
                    text: "parse text code [text] into json data",
                    arguments: {
                        text: {
                            type: "string",
                            defaultValue: "$(\"relative moveable vertically\")imp,tick$=(){u>/u,/u},t:$()tick"
                        }
                    }
                }
            ]
        };
    };
    
    // Code for blocks go here
    
    parsetextcodeintojson({text}) {
        return JSON.stringify(parser(text))
    }
};



(function() {
    var extensionClass = cellParser;
    if (typeof window === "undefined" || !window.vm) {
        Scratch.extensions.register(new extensionClass());
    } else {
        var extensionInstance = new extensionClass(window.vm.extensionManager.runtime);
        var serviceName = window.vm.extensionManager._registerInternalExtension(extensionInstance);
        window.vm.extensionManager._loadedExtensions.set(extensionInstance.getInfo().id, serviceName);
    };
})()