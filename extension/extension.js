// data:text/javascript;base64,bGV0IG1vZHVsZSA9IHt9CmNvbnN0IGFjdGlvbnMgPSAvKC4+KSguKikvZwpjb25zdCBzdHJpbmcgPSAvXCIoLiopXCIvZwpjb25zdCB0cmlnZXJzID0gLyguOikoLiopL2cKY29uc3QgZGF0YSA9IC8oXD8uKSguKikvZwpjb25zdCBmdW5jdGlvblJ1bm5lciA9IC9cJFwoKC4qKVwpKC4qKS9nCmNvbnN0IGZ1bmN0aW9uUmVnZXggPSAvKC4qKVwkPVwoKC4qKVwpeyguKil9L2cKY29uc3QgdmFyaWFibGUgPSAvKC4qKVw9KC4qKS9nCmNvbnN0IHZhcmlhYmxlR2V0dGVyID0gL0AoLiopL2cKY29uc3QgaWZlbHNlID0gLyguKilcPyguKilcfCguKikvZwoKY29uc3Qgc2luZ2xlcyA9IHsKICAgICchcyc6IHsgY29tbWFuZDogJ3N0b3AnIH0sCiAgICAiL2wiOiB7IGNvbW1hbmQ6ICdsZWZ0IGRpcmVjdGlvbicgfSwKICAgICIvciI6IHsgY29tbWFuZDogJ3JpZ2h0IGRpcmVjdGlvbicgfSwKICAgICIvdSI6IHsgY29tbWFuZDogJ3VwIGRpcmVjdGlvbicgfSwKICAgICIvZCI6IHsgY29tbWFuZDogJ2Rvd24gZGlyZWN0aW9uJyB9LAogICAgIi9tIjogeyBjb21tYW5kOiAndHJpZ2VyIGRpcmVjdGlvbicgfSwKICAgICIvYyI6IHsgY29tbWFuZDogJ2Nsb2Nrd2lzZSByb3RhdGlvbicgfSwKICAgICIvdyI6IHsgY29tbWFuZDogJ2NvdW50ZXItY2xvY2t3aXNlIHJvdGF0aW9uJyB9LAogICAgIm5hIjogeyBjb21tYW5kOiAnbm9wJyB9Cn0KY29uc3QgdHJpZ2VyTmFtZXMgPSB7CiAgICAibDoiOiAicHVzaExlZnQiLAogICAgInI6IjogInB1c2hSaWdodCIsCiAgICAidToiOiAicHVzaFVwIiwKICAgICJkOiI6ICJwdXNoRG93biIsCiAgICAiYToiOiAicHVzaEFueXdoZXJlIiwKICAgICJjOiI6ICJyb3RhdGVkIiwKICAgICJ0OiI6ICJ0aWNrIiwKfQoKY29uc3QgcGFyc2VDb21tYW5kID0gKGNvbSkgPT4gewogICAgaWYgKGZ1bmN0aW9uUmVnZXgudGVzdChjb20pKSB7CiAgICAgICAgY29uc3QgY29tbWFuZCA9IGNvbS5zcGxpdChmdW5jdGlvblJlZ2V4KQogICAgICAgIHJldHVybiB7CiAgICAgICAgICAgIGNvbW1hbmQ6ICdmdW5jdGlvbiBkZWZpbml0aW9uJywKICAgICAgICAgICAgbmFtZTogY29tbWFuZFsxXSwKICAgICAgICAgICAgaW5wdXRzOiBjb21tYW5kWzJdLnNwbGl0KCcsJyksCiAgICAgICAgICAgIGNvZGU6IGNvbW1hbmRbM10uc3BsaXQoJywnKS5tYXAocGFyc2VDb21tYW5kKQogICAgICAgIH0KICAgIH0KCiAgICBpZiAodHJpZ2Vycy50ZXN0KGNvbSkpIHsKICAgICAgICBjb25zdCBjb21tYW5kID0gY29tLnNwbGl0KHRyaWdlcnMpCiAgICAgICAgY29uc3QgaW5wdXQgPSBwYXJzZUNvbW1hbmQoY29tbWFuZFsyXSkKICAgICAgICBpbnB1dC5nZXQgPSB0cnVlCiAgICAgICAgcmV0dXJuIHsKICAgICAgICAgICAgY29tbWFuZDogJ3RyaWdlcicsCiAgICAgICAgICAgIHZhcmlhbnQ6IGNvbW1hbmRbMV0sCiAgICAgICAgICAgIGZ1bmM6IGlucHV0CiAgICAgICAgfQogICAgfQogICAgCiAgICBpZiAoZnVuY3Rpb25SdW5uZXIudGVzdChjb20pKSB7CiAgICAgICAgY29uc3QgY29tbWFuZCA9IGNvbS5zcGxpdChmdW5jdGlvblJ1bm5lcikKICAgICAgICByZXR1cm4gewogICAgICAgICAgICBjb21tYW5kOiAnZnVuY3Rpb24gcnVubmVyJywKICAgICAgICAgICAgbmFtZTogY29tbWFuZFsyXSwKICAgICAgICAgICAgaW5wdXRzOiBjb21tYW5kWzFdLnNwbGl0KCcsJykubWFwKHBhcnNlQ29tbWFuZCkKICAgICAgICB9CiAgICB9CiAgICAKICAgIGlmICh2YXJpYWJsZS50ZXN0KGNvbSkpIHsKICAgICAgICBjb25zdCBjb21tYW5kID0gY29tLnNwbGl0KHZhcmlhYmxlKQogICAgICAgIGNvbnN0IGlucHV0ID0gcGFyc2VDb21tYW5kKGNvbW1hbmRbMl0pCiAgICAgICAgaW5wdXQuZ2V0ID0gdHJ1ZQogICAgICAgIHJldHVybiB7CiAgICAgICAgICAgIGNvbW1hbmQ6ICd2YXJpYWJsZSBkZWZpbml0aW9uJywKICAgICAgICAgICAgbmFtZTogY29tbWFuZFsxXSwKICAgICAgICAgICAgdmFsdWU6IGlucHV0CiAgICAgICAgfQogICAgfQogICAgCiAgICBpZiAodmFyaWFibGVHZXR0ZXIudGVzdChjb20pKSB7CiAgICAgICAgY29uc3QgY29tbWFuZCA9IGNvbS5zcGxpdCh2YXJpYWJsZUdldHRlcikKICAgICAgICByZXR1cm4gewogICAgICAgICAgICBjb21tYW5kOiAndmFyaWFibGUgdmFsdWUgZ2V0dGVyJywKICAgICAgICAgICAgbmFtZTogY29tbWFuZFsxXQogICAgICAgIH0KICAgIH0KICAgIAogICAgaWYgKGlmZWxzZS50ZXN0KGNvbSkpIHsKICAgICAgICBjb25zdCBjb21tYW5kID0gY29tLnNwbGl0KGlmZWxzZSkKICAgICAgICBjb25zdCBpbnB1dDEgPSBwYXJzZUNvbW1hbmQoY29tbWFuZFsxXSkKICAgICAgICBpbnB1dDEuZ2V0ID0gdHJ1ZQogICAgICAgIGNvbnN0IGlucHV0MiA9IHBhcnNlQ29tbWFuZChjb21tYW5kWzJdKQogICAgICAgIGlucHV0Mi5nZXQgPSB0cnVlCiAgICAgICAgY29uc3QgaW5wdXQzID0gcGFyc2VDb21tYW5kKGNvbW1hbmRbM10pCiAgICAgICAgaW5wdXQzLmdldCA9IHRydWUKICAgICAgICByZXR1cm4gewogICAgICAgICAgICBjb21tYW5kOiAnaWYgZWxzZScsCiAgICAgICAgICAgIG5hbWU6IGlucHV0MSwKICAgICAgICAgICAgdHJ1ZTogaW5wdXQyLAogICAgICAgICAgICBmYWxzZTogaW5wdXQzCiAgICAgICAgfQogICAgfQoKICAgIGlmIChhY3Rpb25zLnRlc3QoY29tKSkgewogICAgICAgIGNvbnN0IGNvbW1hbmQgPSBjb20uc3BsaXQoYWN0aW9ucykKICAgICAgICBjb25zdCBpbnB1dCA9IHBhcnNlQ29tbWFuZChjb21tYW5kWzJdKQogICAgICAgIGlucHV0LmdldCA9IHRydWUKICAgICAgICByZXR1cm4gewogICAgICAgICAgICBjb21tYW5kOiAnYWN0aW9uJywKICAgICAgICAgICAgdmFyaWFudDogY29tbWFuZFsxXSwKICAgICAgICAgICAgaW5wdXQ6IGlucHV0CiAgICAgICAgfQogICAgfQogICAgCiAgICBpZiAoZGF0YS50ZXN0KGNvbSkpIHsKICAgICAgICBjb25zdCBjb21tYW5kID0gY29tLnNwbGl0KGRhdGEpCiAgICAgICAgY29uc3QgaW5wdXQgPSBwYXJzZUNvbW1hbmQoY29tbWFuZFsyXSkKICAgICAgICBpbnB1dC5nZXQgPSB0cnVlCiAgICAgICAgcmV0dXJuIHsKICAgICAgICAgICAgY29tbWFuZDogJ2RhdGEgcmVhZGVyJywKICAgICAgICAgICAgdmFyaWFudDogY29tbWFuZFsxXSwKICAgICAgICAgICAgaW5wdXQ6IGlucHV0CiAgICAgICAgfQogICAgfQogICAgCiAgICBpZiAoc3RyaW5nLnRlc3QoY29tKSkgewogICAgICAgIGNvbnN0IGNvbW1hbmQgPSBjb20uc3BsaXQoc3RyaW5nKQogICAgICAgIHJldHVybiB7CiAgICAgICAgICAgIGNvbW1hbmQ6ICdzdHJpbmcvbnVtYmVyJywKICAgICAgICAgICAgdmFsdWU6IGNvbW1hbmRbMV0sCiAgICAgICAgfQogICAgfQogICAgCiAgICByZXR1cm4gc2luZ2xlc1tjb21dID8gc2luZ2xlc1tjb21dIDogc2luZ2xlc1snbmEnXQp9Cgpjb25zdCBwYXJzZXIgPSBmdW5jdGlvbihydWxlKSB7CiAgICBydWxlID0gcnVsZS5yZXBsYWNlQWxsKCdcbicsICcnKQogICAgbGV0IGluc2lkZSA9IGZhbHNlCiAgICBsZXQgY29tbWFuZHMgPSBbJyddCiAgICBmb3IgKGxldCBpZHggPSAwLCBjaGFyID0gJyc7IGlkeCA8IHJ1bGUubGVuZ3RoICsgMTsgY2hhciA9IHJ1bGVbaWR4KytdKSB7CiAgICAgICAgaWYgKGNoYXIgPT09ICcsJyAmJiAhaW5zaWRlKSB7CiAgICAgICAgICAgIGNvbW1hbmRzLnB1c2goJycpCiAgICAgICAgICAgIGNvbnRpbnVlCiAgICAgICAgfQogICAgICAgIGNvbW1hbmRzW2NvbW1hbmRzLmxlbmd0aC0xXSArPSBjaGFyCiAgICAgICAgaWYgKGNoYXIgPT09ICciJyB8fCBjaGFyID09PSAnKCcgfHwgY2hhciA9PT0gJ3snKSB7CiAgICAgICAgICAgIGluc2lkZSA9IHRydWUKICAgICAgICAgICAgY29udGludWUKICAgICAgICB9CiAgICAgICAgaWYgKGNoYXIgPT09ICciJyB8fCBjaGFyID09PSAnKScgfHwgY2hhciA9PT0gJ30nKSB7CiAgICAgICAgICAgIGluc2lkZSA9IGZhbHNlCiAgICAgICAgICAgIGNvbnRpbnVlCiAgICAgICAgfQogICAgfQogICAgbGV0IHJldFZhbCA9IHsKICAgICAgICB2YXJzOiB7CiAgICAgICAgICAgIGNkaXI6IDAsCiAgICAgICAgICAgIGNuYW06ICdub25lJwogICAgICAgIH0sCiAgICAgICAgZnVuY3M6IHsKICAgICAgICAgICAgaW1wOiB7CiAgICAgICAgICAgICAgICBpbnB1dHM6IFsnbW9kdWxlJ10sCiAgICAgICAgICAgICAgICBjb21tYW5kczogeyAKICAgICAgICAgICAgICAgICAgICBjb21tYW5kOiAnY2FsbCcsIAogICAgICAgICAgICAgICAgICAgIGZ1bmM6ICdpbXBvcnRlcicsIAogICAgICAgICAgICAgICAgICAgIGFyZ3M6IFsKICAgICAgICAgICAgICAgICAgICAgICAgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgY29tbWFuZDogJ3ZhcmlhYmxlIHZhbHVlIGdldHRlcicsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiAnbW9kdWxlJwogICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgXSAKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgfSwKICAgICAgICAgICAgcG9zOiB7CiAgICAgICAgICAgICAgICBpbnB1dHM6IFsneCcsICd5J10sCiAgICAgICAgICAgICAgICBjb21tYW5kczogeyAKICAgICAgICAgICAgICAgICAgICBjb21tYW5kOiAnY2FsbCcsIAogICAgICAgICAgICAgICAgICAgIGZ1bmM6ICdwb3NpdGlvbiBjYWxsY3VsYXRvcicgLAogICAgICAgICAgICAgICAgICAgIGFyZ3M6IFsKICAgICAgICAgICAgICAgICAgICAgICAgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgY29tbWFuZDogJ3ZhcmlhYmxlIHZhbHVlIGdldHRlcicsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiAneCcKICAgICAgICAgICAgICAgICAgICAgICAgfSwKICAgICAgICAgICAgICAgICAgICAgICAgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgY29tbWFuZDogJ3ZhcmlhYmxlIHZhbHVlIGdldHRlcicsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiAneScKICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgIF0gCiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0sCiAgICAgICAgICAgIGNhbGw6IHsKICAgICAgICAgICAgICAgIGlucHV0czogWydmdW5jdGlvbiddLAogICAgICAgICAgICAgICAgY29tbWFuZHM6IHsgCiAgICAgICAgICAgICAgICAgICAgY29tbWFuZDogJ2NhbGwnLCAKICAgICAgICAgICAgICAgICAgICBmdW5jOiB7CiAgICAgICAgICAgICAgICAgICAgICAgIGNvbW1hbmQ6ICd2YXJpYWJsZSB2YWx1ZSBnZXR0ZXInLAogICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiAnZnVuY3Rpb24nCiAgICAgICAgICAgICAgICAgICAgfSwKICAgICAgICAgICAgICAgICAgICBhcmdzOiBbCiAgICAgICAgICAgICAgICAgICAgICAgIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbW1hbmQ6ICd2YXJpYWJsZSB2YWx1ZSBnZXR0ZXInLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogJ1tmdW5jQXJnc10nCiAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICBdCiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0sCiAgICAgICAgICAgIG5ld05laWdoYm9yOiB7CiAgICAgICAgICAgICAgICBpbnB1dHM6IFsnbG9jYXRpb24nLCAndHlwZSddLAogICAgICAgICAgICAgICAgY29tbWFuZHM6IHsgCiAgICAgICAgICAgICAgICAgICAgY29tbWFuZDogJ2NhbGwnLCAKICAgICAgICAgICAgICAgICAgICBmdW5jOiAnY3JlYXRlIG5ldyBuZWlnaGJvcicsCiAgICAgICAgICAgICAgICAgICAgYXJnczogWwogICAgICAgICAgICAgICAgICAgICAgICB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb21tYW5kOiAndmFyaWFibGUgdmFsdWUgZ2V0dGVyJywKICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6ICdsb2NhdGlvbicKICAgICAgICAgICAgICAgICAgICAgICAgfSwKICAgICAgICAgICAgICAgICAgICAgICAgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgY29tbWFuZDogJ3ZhcmlhYmxlIHZhbHVlIGdldHRlcicsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiAndHlwZScKICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgIF0KICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgfQogICAgICAgIH0sCiAgICAgICAgdHJpZ2VyczogewogICAgICAgICAgICB0aWNrOiBbXSwKICAgICAgICAgICAgcHVzaFVwOiBbXSwKICAgICAgICAgICAgcHVzaERvd246IFtdLAogICAgICAgICAgICBwdXNoTGVmdDogW10sCiAgICAgICAgICAgIHB1c2hSaWdodDogW10sCiAgICAgICAgICAgIHB1c2hBbnl3aGVyZTogW10sCiAgICAgICAgICAgIHJvdGF0ZWQ6IFtdCiAgICAgICAgfSwKICAgICAgICBjb21tYW5kczogW10KICAgIH0KICAgIHJldFZhbC5jb21tYW5kcyA9IGNvbW1hbmRzID0gY29tbWFuZHMubWFwKGNvbW1hbmQgPT4gewogICAgICAgIGNvbW1hbmQgPSBwYXJzZUNvbW1hbmQoY29tbWFuZCkKICAgICAgICBpZiAoY29tbWFuZC5jb21tYW5kID09PSAndHJpZ2VyJykgewogICAgICAgICAgICByZXRWYWwudHJpZ2Vyc1t0cmlnZXJOYW1lc1tjb21tYW5kLnZhcmlhbnRdXS5wdXNoKGNvbW1hbmQuZnVuYykKICAgICAgICB9CiAgICAgICAgcmV0dXJuIGNvbW1hbmQKICAgIH0pCgogICAgcmV0dXJuIHJldFZhbAp9Cgptb2R1bGUuZXhwb3J0cyA9IHBhcnNlcgoKCmNsYXNzIGNlbGxQYXJzZXIgew0KICAgIGNvbnN0cnVjdG9yIChydW50aW1lKSB7DQogICAgICAgIC8vIEV4dGVuc2lvbiBzdHVmZg0KICAgICAgICB0aGlzLnJ1bnRpbWUgPSBydW50aW1lOw0KICAgIH0NCg0KICAgIGdldEluZm8gKCkgew0KICAgICAgICByZXR1cm4gew0KICAgICAgICAgICAgaWQ6ICdjZWxscGFyc2VyJywNCiAgICAgICAgICAgIG5hbWU6ICdHYW0gQ2VsbCBSdWxlIFBhcnNlcicsDQogICAgICAgICAgICBjb2xvcjE6ICcjZmZiYjAwJywNCiAgICAgICAgICAgIGNvbG9yMjogJyNmZmFhMDAnLA0KICAgICAgICAgICAgYmxvY2tzOiBbDQogICAgICAgICAgICAgICAgew0KICAgICAgICAgICAgICAgICAgICBvcGNvZGU6ICdwYXJzZXRleHRjb2RlaW50b2pzb24nLA0KICAgICAgICAgICAgICAgICAgICBibG9ja1R5cGU6ICJyZXBvcnRlciIsDQogICAgICAgICAgICAgICAgICAgIHRleHQ6ICJwYXJzZSB0ZXh0IGNvZGUgW3RleHRdIGludG8ganNvbiBkYXRhIiwNCiAgICAgICAgICAgICAgICAgICAgYXJndW1lbnRzOiB7DQogICAgICAgICAgICAgICAgICAgICAgICB0ZXh0OiB7DQogICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogInN0cmluZyIsDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdFZhbHVlOiAiJChcInJlbGF0aXZlIG1vdmVhYmxlIHZlcnRpY2FsbHlcIilpbXAsdGljayQ9KCl7dT4vdSwvdX0sdDokKCl0aWNrIg0KICAgICAgICAgICAgICAgICAgICAgICAgfQ0KICAgICAgICAgICAgICAgICAgICB9DQogICAgICAgICAgICAgICAgfQ0KICAgICAgICAgICAgXQ0KICAgICAgICB9Ow0KICAgIH07DQogICAgDQogICAgLy8gQ29kZSBmb3IgYmxvY2tzIGdvIGhlcmUNCiAgICANCiAgICBwYXJzZXRleHRjb2RlaW50b2pzb24oe3RleHR9KSB7DQogICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShwYXJzZXIodGV4dCkpDQogICAgfQ0KfTsNCg0KDQoNCihmdW5jdGlvbigpIHsNCiAgICB2YXIgZXh0ZW5zaW9uQ2xhc3MgPSBjZWxsUGFyc2VyOw0KICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSAidW5kZWZpbmVkIiB8fCAhd2luZG93LnZtKSB7DQogICAgICAgIFNjcmF0Y2guZXh0ZW5zaW9ucy5yZWdpc3RlcihuZXcgZXh0ZW5zaW9uQ2xhc3MoKSk7DQogICAgfSBlbHNlIHsNCiAgICAgICAgdmFyIGV4dGVuc2lvbkluc3RhbmNlID0gbmV3IGV4dGVuc2lvbkNsYXNzKHdpbmRvdy52bS5leHRlbnNpb25NYW5hZ2VyLnJ1bnRpbWUpOw0KICAgICAgICB2YXIgc2VydmljZU5hbWUgPSB3aW5kb3cudm0uZXh0ZW5zaW9uTWFuYWdlci5fcmVnaXN0ZXJJbnRlcm5hbEV4dGVuc2lvbihleHRlbnNpb25JbnN0YW5jZSk7DQogICAgICAgIHdpbmRvdy52bS5leHRlbnNpb25NYW5hZ2VyLl9sb2FkZWRFeHRlbnNpb25zLnNldChleHRlbnNpb25JbnN0YW5jZS5nZXRJbmZvKCkuaWQsIHNlcnZpY2VOYW1lKTsNCiAgICB9Ow0KfSkoKQ==

let module = {}
const actions = /(.>)(.*)/g
const string = /\"(.*)\"/g
const trigers = /(.:)(.*)/g
const data = /(\?.)(.*)/g
const functionRunner = /\$\((.*)\)(.*)/g
const functionRegex = /(.*)\$=\((.*)\){(.*)}/g
const variable = /(.*)\=(.*)/g
const variableGetter = /@(.*)/g
const ifelse = /(.*)\?(.*)\|(.*)/g

const singles = {
    '!s': { command: 'stop' },
    "/l": { command: 'left direction' },
    "/r": { command: 'right direction' },
    "/u": { command: 'up direction' },
    "/d": { command: 'down direction' },
    "/m": { command: 'triger direction' },
    "/c": { command: 'clockwise rotation' },
    "/w": { command: 'counter-clockwise rotation' },
    "na": { command: 'nop' }
}
const trigerNames = {
    "l:": "pushLeft",
    "r:": "pushRight",
    "u:": "pushUp",
    "d:": "pushDown",
    "a:": "pushAnywhere",
    "c:": "rotated",
    "t:": "tick",
}

const parseCommand = (com) => {
    if (functionRegex.test(com)) {
        const command = com.split(functionRegex)
        return {
            command: 'function definition',
            name: command[1],
            inputs: command[2].split(','),
            code: command[3].split(',').map(parseCommand)
        }
    }

    if (trigers.test(com)) {
        const command = com.split(trigers)
        const input = parseCommand(command[2])
        input.get = true
        return {
            command: 'triger',
            variant: command[1],
            func: input
        }
    }
    
    if (functionRunner.test(com)) {
        const command = com.split(functionRunner)
        return {
            command: 'function runner',
            name: command[2],
            inputs: command[1].split(',').map(parseCommand)
        }
    }
    
    if (variable.test(com)) {
        const command = com.split(variable)
        const input = parseCommand(command[2])
        input.get = true
        return {
            command: 'variable definition',
            name: command[1],
            value: input
        }
    }
    
    if (variableGetter.test(com)) {
        const command = com.split(variableGetter)
        return {
            command: 'variable value getter',
            name: command[1]
        }
    }
    
    if (ifelse.test(com)) {
        const command = com.split(ifelse)
        const input1 = parseCommand(command[1])
        input1.get = true
        const input2 = parseCommand(command[2])
        input2.get = true
        const input3 = parseCommand(command[3])
        input3.get = true
        return {
            command: 'if else',
            name: input1,
            true: input2,
            false: input3
        }
    }

    if (actions.test(com)) {
        const command = com.split(actions)
        const input = parseCommand(command[2])
        input.get = true
        return {
            command: 'action',
            variant: command[1],
            input: input
        }
    }
    
    if (data.test(com)) {
        const command = com.split(data)
        const input = parseCommand(command[2])
        input.get = true
        return {
            command: 'data reader',
            variant: command[1],
            input: input
        }
    }
    
    if (string.test(com)) {
        const command = com.split(string)
        return {
            command: 'string/number',
            value: command[1],
        }
    }
    
    return singles[com] ? singles[com] : singles['na']
}

const parser = function(rule) {
    rule = rule.replaceAll('\n', '')
    let inside = false
    let commands = ['']
    for (let idx = 0, char = ''; idx < rule.length + 1; char = rule[idx++]) {
        if (char === ',' && !inside) {
            commands.push('')
            continue
        }
        commands[commands.length-1] += char
        if (char === '"' || char === '(' || char === '{') {
            inside = true
            continue
        }
        if (char === '"' || char === ')' || char === '}') {
            inside = false
            continue
        }
    }
    let retVal = {
        vars: {
            cdir: 0,
            cnam: 'none'
        },
        funcs: {
            imp: {
                inputs: ['module'],
                commands: { 
                    command: 'call', 
                    func: 'importer', 
                    args: [
                        {
                            command: 'variable value getter',
                            name: 'module'
                        }
                    ] 
                }
            },
            pos: {
                inputs: ['x', 'y'],
                commands: { 
                    command: 'call', 
                    func: 'position callculator' ,
                    args: [
                        {
                            command: 'variable value getter',
                            name: 'x'
                        },
                        {
                            command: 'variable value getter',
                            name: 'y'
                        }
                    ] 
                }
            },
            call: {
                inputs: ['function'],
                commands: { 
                    command: 'call', 
                    func: {
                        command: 'variable value getter',
                        name: 'function'
                    },
                    args: [
                        {
                            command: 'variable value getter',
                            name: '[funcArgs]'
                        }
                    ]
                }
            },
            newNeighbor: {
                inputs: ['location', 'type'],
                commands: { 
                    command: 'call', 
                    func: 'create new neighbor',
                    args: [
                        {
                            command: 'variable value getter',
                            name: 'location'
                        },
                        {
                            command: 'variable value getter',
                            name: 'type'
                        }
                    ]
                }
            }
        },
        trigers: {
            tick: [],
            pushUp: [],
            pushDown: [],
            pushLeft: [],
            pushRight: [],
            pushAnywhere: [],
            rotated: []
        },
        commands: []
    }
    retVal.commands = commands = commands.map(command => {
        command = parseCommand(command)
        if (command.command === 'triger') {
            retVal.trigers[trigerNames[command.variant]].push(command.func)
        }
        return command
    })

    return retVal
}

module.exports = parser


class cellParser {
    constructor (runtime) {
        // Extension stuff
        this.runtime = runtime;
    }

    getInfo () {
        return {
            id: 'cellparser',
            name: 'Gam Cell Rule Parser',
            color1: '#ffbb00',
            color2: '#ffaa00',
            blocks: [
                {
                    opcode: 'parsetextcodeintojson',
                    blockType: "reporter",
                    text: "parse text code [text] into json data",
                    arguments: {
                        text: {
                            type: "string",
                            defaultValue: "$(\"relative moveable vertically\")imp,tick$=(){u>/u,/u},t:$()tick"
                        }
                    }
                }
            ]
        };
    };
    
    // Code for blocks go here
    
    parsetextcodeintojson({text}) {
        return JSON.stringify(parser(text))
    }
};



(function() {
    var extensionClass = cellParser;
    if (typeof window === "undefined" || !window.vm) {
        Scratch.extensions.register(new extensionClass());
    } else {
        var extensionInstance = new extensionClass(window.vm.extensionManager.runtime);
        var serviceName = window.vm.extensionManager._registerInternalExtension(extensionInstance);
        window.vm.extensionManager._loadedExtensions.set(extensionInstance.getInfo().id, serviceName);
    };
})()