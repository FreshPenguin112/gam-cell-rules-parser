// data:text/javascript;base64,Y29uc3QgYWN0aW9ucyA9IC8oLj4pKC4qKS9nCmNvbnN0IHN0cmluZyA9IC9cIiguKilcIi9nCmNvbnN0IHRyaWdlcnMgPSAvKC46KSguKikvZwpjb25zdCBkYXRhID0gLyhcPy4pKC4qKS9nCmNvbnN0IGZ1bmN0aW9uUnVubmVyID0gL1wkXCgoLiopXCkoLiopL2cKY29uc3QgZnVuY3Rpb25SZWdleCA9IC8oLiopXCQ9XCgoLiopXCl7KC4qKX0vZwpjb25zdCB2YXJpYWJsZSA9IC8oLiopXD0oLiopL2cKY29uc3QgdmFyaWFibGVHZXR0ZXIgPSAvQCguKikvZwpjb25zdCBpZmVsc2UgPSAvKC4qKVw/KC4qKVx8KC4qKS9nCgpjb25zdCBzaW5nbGVzID0gewogICAgJyFzJzogeyBjb21tYW5kOiAnc3RvcCcgfSwKICAgICIvbCI6IHsgY29tbWFuZDogJ2xlZnQgZGlyZWN0aW9uJyB9LAogICAgIi9yIjogeyBjb21tYW5kOiAncmlnaHQgZGlyZWN0aW9uJyB9LAogICAgIi91IjogeyBjb21tYW5kOiAndXAgZGlyZWN0aW9uJyB9LAogICAgIi9kIjogeyBjb21tYW5kOiAnZG93biBkaXJlY3Rpb24nIH0sCiAgICAiL20iOiB7IGNvbW1hbmQ6ICd0cmlnZXIgZGlyZWN0aW9uJyB9LAogICAgIi9jIjogeyBjb21tYW5kOiAnY2xvY2t3aXNlIHJvdGF0aW9uJyB9LAogICAgIi93IjogeyBjb21tYW5kOiAnY291bnRlci1jbG9ja3dpc2Ugcm90YXRpb24nIH0sCiAgICAibmEiOiB7IGNvbW1hbmQ6ICdub3AnIH0KfQpjb25zdCB0cmlnZXJOYW1lcyA9IHsKICAgICJsOiI6ICJwdXNoTGVmdCIsCiAgICAicjoiOiAicHVzaFJpZ2h0IiwKICAgICJ1OiI6ICJwdXNoVXAiLAogICAgImQ6IjogInB1c2hEb3duIiwKICAgICJhOiI6ICJwdXNoQW55d2hlcmUiLAogICAgImM6IjogInJvdGF0ZWQiLAogICAgInQ6IjogInRpY2siLAp9Cgpjb25zdCBwYXJzZUNvbW1hbmQgPSAoY29tKSA9PiB7CiAgICBpZiAoZnVuY3Rpb25SZWdleC50ZXN0KGNvbSkpIHsKICAgICAgICBjb25zdCBjb21tYW5kID0gY29tLnNwbGl0KGZ1bmN0aW9uUmVnZXgpCiAgICAgICAgcmV0dXJuIHsKICAgICAgICAgICAgY29tbWFuZDogJ2Z1bmN0aW9uIGRlZmluaXRpb24nLAogICAgICAgICAgICBuYW1lOiBjb21tYW5kWzFdLAogICAgICAgICAgICBpbnB1dHM6IGNvbW1hbmRbMl0uc3BsaXQoJywnKSwKICAgICAgICAgICAgY29kZTogY29tbWFuZFszXS5zcGxpdCgnLCcpLm1hcChwYXJzZUNvbW1hbmQpCiAgICAgICAgfQogICAgfQoKICAgIGlmICh0cmlnZXJzLnRlc3QoY29tKSkgewogICAgICAgIGNvbnN0IGNvbW1hbmQgPSBjb20uc3BsaXQodHJpZ2VycykKICAgICAgICBjb25zdCBpbnB1dCA9IHBhcnNlQ29tbWFuZChjb21tYW5kWzJdKQogICAgICAgIGlucHV0LmdldCA9IHRydWUKICAgICAgICByZXR1cm4gewogICAgICAgICAgICBjb21tYW5kOiAndHJpZ2VyJywKICAgICAgICAgICAgdmFyaWFudDogY29tbWFuZFsxXSwKICAgICAgICAgICAgZnVuYzogaW5wdXQKICAgICAgICB9CiAgICB9CiAgICAKICAgIGlmIChmdW5jdGlvblJ1bm5lci50ZXN0KGNvbSkpIHsKICAgICAgICBjb25zdCBjb21tYW5kID0gY29tLnNwbGl0KGZ1bmN0aW9uUnVubmVyKQogICAgICAgIHJldHVybiB7CiAgICAgICAgICAgIGNvbW1hbmQ6ICdmdW5jdGlvbiBydW5uZXInLAogICAgICAgICAgICBuYW1lOiBjb21tYW5kWzJdLAogICAgICAgICAgICBpbnB1dHM6IGNvbW1hbmRbMV0uc3BsaXQoJywnKS5tYXAocGFyc2VDb21tYW5kKQogICAgICAgIH0KICAgIH0KICAgIAogICAgaWYgKHZhcmlhYmxlLnRlc3QoY29tKSkgewogICAgICAgIGNvbnN0IGNvbW1hbmQgPSBjb20uc3BsaXQodmFyaWFibGUpCiAgICAgICAgY29uc3QgaW5wdXQgPSBwYXJzZUNvbW1hbmQoY29tbWFuZFsyXSkKICAgICAgICBpbnB1dC5nZXQgPSB0cnVlCiAgICAgICAgcmV0dXJuIHsKICAgICAgICAgICAgY29tbWFuZDogJ3ZhcmlhYmxlIGRlZmluaXRpb24nLAogICAgICAgICAgICBuYW1lOiBjb21tYW5kWzFdLAogICAgICAgICAgICB2YWx1ZTogaW5wdXQKICAgICAgICB9CiAgICB9CiAgICAKICAgIGlmICh2YXJpYWJsZUdldHRlci50ZXN0KGNvbSkpIHsKICAgICAgICBjb25zdCBjb21tYW5kID0gY29tLnNwbGl0KHZhcmlhYmxlR2V0dGVyKQogICAgICAgIHJldHVybiB7CiAgICAgICAgICAgIGNvbW1hbmQ6ICd2YXJpYWJsZSB2YWx1ZSBnZXR0ZXInLAogICAgICAgICAgICBuYW1lOiBjb21tYW5kWzFdCiAgICAgICAgfQogICAgfQogICAgCiAgICBpZiAoaWZlbHNlLnRlc3QoY29tKSkgewogICAgICAgIGNvbnN0IGNvbW1hbmQgPSBjb20uc3BsaXQoaWZlbHNlKQogICAgICAgIGNvbnN0IGlucHV0MSA9IHBhcnNlQ29tbWFuZChjb21tYW5kWzFdKQogICAgICAgIGlucHV0MS5nZXQgPSB0cnVlCiAgICAgICAgY29uc3QgaW5wdXQyID0gcGFyc2VDb21tYW5kKGNvbW1hbmRbMl0pCiAgICAgICAgaW5wdXQyLmdldCA9IHRydWUKICAgICAgICBjb25zdCBpbnB1dDMgPSBwYXJzZUNvbW1hbmQoY29tbWFuZFszXSkKICAgICAgICBpbnB1dDMuZ2V0ID0gdHJ1ZQogICAgICAgIHJldHVybiB7CiAgICAgICAgICAgIGNvbW1hbmQ6ICdpZiBlbHNlJywKICAgICAgICAgICAgbmFtZTogaW5wdXQxLAogICAgICAgICAgICB0cnVlOiBpbnB1dDIsCiAgICAgICAgICAgIGZhbHNlOiBpbnB1dDMKICAgICAgICB9CiAgICB9CgogICAgaWYgKGFjdGlvbnMudGVzdChjb20pKSB7CiAgICAgICAgY29uc3QgY29tbWFuZCA9IGNvbS5zcGxpdChhY3Rpb25zKQogICAgICAgIGNvbnN0IGlucHV0ID0gcGFyc2VDb21tYW5kKGNvbW1hbmRbMl0pCiAgICAgICAgaW5wdXQuZ2V0ID0gdHJ1ZQogICAgICAgIHJldHVybiB7CiAgICAgICAgICAgIGNvbW1hbmQ6ICdhY3Rpb24nLAogICAgICAgICAgICB2YXJpYW50OiBjb21tYW5kWzFdLAogICAgICAgICAgICBpbnB1dDogaW5wdXQKICAgICAgICB9CiAgICB9CiAgICAKICAgIGlmIChkYXRhLnRlc3QoY29tKSkgewogICAgICAgIGNvbnN0IGNvbW1hbmQgPSBjb20uc3BsaXQoZGF0YSkKICAgICAgICBjb25zdCBpbnB1dCA9IHBhcnNlQ29tbWFuZChjb21tYW5kWzJdKQogICAgICAgIGlucHV0LmdldCA9IHRydWUKICAgICAgICByZXR1cm4gewogICAgICAgICAgICBjb21tYW5kOiAnZGF0YSByZWFkZXInLAogICAgICAgICAgICB2YXJpYW50OiBjb21tYW5kWzFdLAogICAgICAgICAgICBpbnB1dDogaW5wdXQKICAgICAgICB9CiAgICB9CiAgICAKICAgIGlmIChzdHJpbmcudGVzdChjb20pKSB7CiAgICAgICAgY29uc3QgY29tbWFuZCA9IGNvbS5zcGxpdChzdHJpbmcpCiAgICAgICAgcmV0dXJuIHsKICAgICAgICAgICAgY29tbWFuZDogJ3N0cmluZy9udW1iZXInLAogICAgICAgICAgICB2YWx1ZTogY29tbWFuZFsxXSwKICAgICAgICB9CiAgICB9CiAgICAKICAgIHJldHVybiBzaW5nbGVzW2NvbV0gPyBzaW5nbGVzW2NvbV0gOiBzaW5nbGVzWyduYSddCn0KCmNvbnN0IHBhcnNlciA9IGZ1bmN0aW9uKHJ1bGUpIHsKICAgIHJ1bGUgPSBydWxlLnJlcGxhY2VBbGwoJ1xuJywgJycpCiAgICBsZXQgaW5zaWRlID0gZmFsc2UKICAgIGxldCBjb21tYW5kcyA9IFsnJ10KICAgIGZvciAobGV0IGlkeCA9IDAsIGNoYXIgPSAnJzsgaWR4IDwgcnVsZS5sZW5ndGggKyAxOyBjaGFyID0gcnVsZVtpZHgrK10pIHsKICAgICAgICBpZiAoY2hhciA9PT0gJywnICYmICFpbnNpZGUpIHsKICAgICAgICAgICAgY29tbWFuZHMucHVzaCgnJykKICAgICAgICAgICAgY29udGludWUKICAgICAgICB9CiAgICAgICAgY29tbWFuZHNbY29tbWFuZHMubGVuZ3RoLTFdICs9IGNoYXIKICAgICAgICBpZiAoY2hhciA9PT0gJyInIHx8IGNoYXIgPT09ICcoJyB8fCBjaGFyID09PSAneycpIHsKICAgICAgICAgICAgaW5zaWRlID0gdHJ1ZQogICAgICAgICAgICBjb250aW51ZQogICAgICAgIH0KICAgICAgICBpZiAoY2hhciA9PT0gJyInIHx8IGNoYXIgPT09ICcpJyB8fCBjaGFyID09PSAnfScpIHsKICAgICAgICAgICAgaW5zaWRlID0gZmFsc2UKICAgICAgICAgICAgY29udGludWUKICAgICAgICB9CiAgICB9CiAgICBsZXQgcmV0VmFsID0gewogICAgICAgIHZhcnM6IHsKICAgICAgICAgICAgY2RpcjogMCwKICAgICAgICAgICAgY25hbTogJ25vbmUnCiAgICAgICAgfSwKICAgICAgICBmdW5jczogewogICAgICAgICAgICBpbXA6IHsKICAgICAgICAgICAgICAgIGlucHV0czogWydtb2R1bGUnXSwKICAgICAgICAgICAgICAgIGNvbW1hbmRzOiB7IAogICAgICAgICAgICAgICAgICAgIGNvbW1hbmQ6ICdjYWxsJywgCiAgICAgICAgICAgICAgICAgICAgZnVuYzogJ2ltcG9ydGVyJywgCiAgICAgICAgICAgICAgICAgICAgYXJnczogWwogICAgICAgICAgICAgICAgICAgICAgICB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb21tYW5kOiAndmFyaWFibGUgdmFsdWUgZ2V0dGVyJywKICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6ICdtb2R1bGUnCiAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICBdIAogICAgICAgICAgICAgICAgfQogICAgICAgICAgICB9LAogICAgICAgICAgICBwb3M6IHsKICAgICAgICAgICAgICAgIGlucHV0czogWyd4JywgJ3knXSwKICAgICAgICAgICAgICAgIGNvbW1hbmRzOiB7IAogICAgICAgICAgICAgICAgICAgIGNvbW1hbmQ6ICdjYWxsJywgCiAgICAgICAgICAgICAgICAgICAgZnVuYzogJ3Bvc2l0aW9uIGNhbGxjdWxhdG9yJyAsCiAgICAgICAgICAgICAgICAgICAgYXJnczogWwogICAgICAgICAgICAgICAgICAgICAgICB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb21tYW5kOiAndmFyaWFibGUgdmFsdWUgZ2V0dGVyJywKICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6ICd4JwogICAgICAgICAgICAgICAgICAgICAgICB9LAogICAgICAgICAgICAgICAgICAgICAgICB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb21tYW5kOiAndmFyaWFibGUgdmFsdWUgZ2V0dGVyJywKICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6ICd5JwogICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgXSAKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgfSwKICAgICAgICAgICAgY2FsbDogewogICAgICAgICAgICAgICAgaW5wdXRzOiBbJ2Z1bmN0aW9uJ10sCiAgICAgICAgICAgICAgICBjb21tYW5kczogeyAKICAgICAgICAgICAgICAgICAgICBjb21tYW5kOiAnY2FsbCcsIAogICAgICAgICAgICAgICAgICAgIGZ1bmM6IHsKICAgICAgICAgICAgICAgICAgICAgICAgY29tbWFuZDogJ3ZhcmlhYmxlIHZhbHVlIGdldHRlcicsCiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6ICdmdW5jdGlvbicKICAgICAgICAgICAgICAgICAgICB9LAogICAgICAgICAgICAgICAgICAgIGFyZ3M6IFsKICAgICAgICAgICAgICAgICAgICAgICAgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgY29tbWFuZDogJ3ZhcmlhYmxlIHZhbHVlIGdldHRlcicsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiAnW2Z1bmNBcmdzXScKICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgIF0KICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgfSwKICAgICAgICAgICAgbmV3TmVpZ2hib3I6IHsKICAgICAgICAgICAgICAgIGlucHV0czogWydsb2NhdGlvbicsICd0eXBlJ10sCiAgICAgICAgICAgICAgICBjb21tYW5kczogeyAKICAgICAgICAgICAgICAgICAgICBjb21tYW5kOiAnY2FsbCcsIAogICAgICAgICAgICAgICAgICAgIGZ1bmM6ICdjcmVhdGUgbmV3IG5laWdoYm9yJywKICAgICAgICAgICAgICAgICAgICBhcmdzOiBbCiAgICAgICAgICAgICAgICAgICAgICAgIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbW1hbmQ6ICd2YXJpYWJsZSB2YWx1ZSBnZXR0ZXInLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogJ2xvY2F0aW9uJwogICAgICAgICAgICAgICAgICAgICAgICB9LAogICAgICAgICAgICAgICAgICAgICAgICB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb21tYW5kOiAndmFyaWFibGUgdmFsdWUgZ2V0dGVyJywKICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6ICd0eXBlJwogICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgXQogICAgICAgICAgICAgICAgfQogICAgICAgICAgICB9CiAgICAgICAgfSwKICAgICAgICB0cmlnZXJzOiB7CiAgICAgICAgICAgIHRpY2s6IFtdLAogICAgICAgICAgICBwdXNoVXA6IFtdLAogICAgICAgICAgICBwdXNoRG93bjogW10sCiAgICAgICAgICAgIHB1c2hMZWZ0OiBbXSwKICAgICAgICAgICAgcHVzaFJpZ2h0OiBbXSwKICAgICAgICAgICAgcHVzaEFueXdoZXJlOiBbXSwKICAgICAgICAgICAgcm90YXRlZDogW10KICAgICAgICB9LAogICAgICAgIGNvbW1hbmRzOiBbXQogICAgfQogICAgcmV0VmFsLmNvbW1hbmRzID0gY29tbWFuZHMgPSBjb21tYW5kcy5tYXAoY29tbWFuZCA9PiB7CiAgICAgICAgY29tbWFuZCA9IHBhcnNlQ29tbWFuZChjb21tYW5kKQogICAgICAgIGlmIChjb21tYW5kLmNvbW1hbmQgPT09ICd0cmlnZXInKSB7CiAgICAgICAgICAgIHJldFZhbC50cmlnZXJzW3RyaWdlck5hbWVzW2NvbW1hbmQudmFyaWFudF1dLnB1c2goY29tbWFuZC5mdW5jKQogICAgICAgIH0KICAgICAgICByZXR1cm4gY29tbWFuZAogICAgfSkKCiAgICByZXR1cm4gcmV0VmFsCn0KCm1vZHVsZS5leHBvcnRzID0gcGFyc2VyCgoKY2xhc3MgY2VsbFBhcnNlciB7DQogICAgY29uc3RydWN0b3IgKHJ1bnRpbWUpIHsNCiAgICAgICAgLy8gRXh0ZW5zaW9uIHN0dWZmDQogICAgICAgIHRoaXMucnVudGltZSA9IHJ1bnRpbWU7DQogICAgfQ0KDQogICAgZ2V0SW5mbyAoKSB7DQogICAgICAgIHJldHVybiB7DQogICAgICAgICAgICBpZDogJ2NlbGxwYXJzZXInLA0KICAgICAgICAgICAgbmFtZTogJ0dhbSBDZWxsIFJ1bGUgUGFyc2VyJywNCiAgICAgICAgICAgIGNvbG9yMTogJyM0NTc2YjRkJywNCiAgICAgICAgICAgIGJsb2NrczogWw0KICAgICAgICAgICAgICAgIHsNCiAgICAgICAgICAgICAgICAgICAgb3Bjb2RlOiAncGFyc2V0ZXh0Y29kZWludG9qc29uJywNCiAgICAgICAgICAgICAgICAgICAgYmxvY2tUeXBlOiAicmVwb3J0ZXIiLA0KICAgICAgICAgICAgICAgICAgICB0ZXh0OiAicGFyc2UgdGV4dCBjb2RlIFt0ZXh0XSBpbnRvIGpzb24gZGF0YSIsDQogICAgICAgICAgICAgICAgICAgIGFyZ3VtZW50czogew0KICAgICAgICAgICAgICAgICAgICAgICAgdGV4dDogew0KICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICJzdHJpbmciLA0KICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHRWYWx1ZTogIiQoXCJyZWxhdGl2ZSBtb3ZlYWJsZSB2ZXJ0aWNhbGx5XCIpaW1wLHRpY2skPSgpe3U+L3UsL3V9LHQ6JCgpdGljayINCiAgICAgICAgICAgICAgICAgICAgICAgIH0NCiAgICAgICAgICAgICAgICAgICAgfQ0KICAgICAgICAgICAgICAgIH0NCiAgICAgICAgICAgIF0NCiAgICAgICAgfTsNCiAgICB9Ow0KICAgIA0KICAgIC8vIENvZGUgZm9yIGJsb2NrcyBnbyBoZXJlDQogICAgDQogICAgcGFyc2V0ZXh0Y29kZWludG9qc29uKHt0ZXh0fSkgew0KICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkocGFyc2VyKHRleHQpKQ0KICAgIH0NCn07DQoNCg0KDQooZnVuY3Rpb24oKSB7DQogICAgdmFyIGV4dGVuc2lvbkNsYXNzID0gY2VsbFBhcnNlcjsNCiAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gInVuZGVmaW5lZCIgfHwgIXdpbmRvdy52bSkgew0KICAgICAgICBTY3JhdGNoLmV4dGVuc2lvbnMucmVnaXN0ZXIobmV3IGV4dGVuc2lvbkNsYXNzKCkpOw0KICAgIH0gZWxzZSB7DQogICAgICAgIHZhciBleHRlbnNpb25JbnN0YW5jZSA9IG5ldyBleHRlbnNpb25DbGFzcyh3aW5kb3cudm0uZXh0ZW5zaW9uTWFuYWdlci5ydW50aW1lKTsNCiAgICAgICAgdmFyIHNlcnZpY2VOYW1lID0gd2luZG93LnZtLmV4dGVuc2lvbk1hbmFnZXIuX3JlZ2lzdGVySW50ZXJuYWxFeHRlbnNpb24oZXh0ZW5zaW9uSW5zdGFuY2UpOw0KICAgICAgICB3aW5kb3cudm0uZXh0ZW5zaW9uTWFuYWdlci5fbG9hZGVkRXh0ZW5zaW9ucy5zZXQoZXh0ZW5zaW9uSW5zdGFuY2UuZ2V0SW5mbygpLmlkLCBzZXJ2aWNlTmFtZSk7DQogICAgfTsNCn0pKCk=

const actions = /(.>)(.*)/g
const string = /\"(.*)\"/g
const trigers = /(.:)(.*)/g
const data = /(\?.)(.*)/g
const functionRunner = /\$\((.*)\)(.*)/g
const functionRegex = /(.*)\$=\((.*)\){(.*)}/g
const variable = /(.*)\=(.*)/g
const variableGetter = /@(.*)/g
const ifelse = /(.*)\?(.*)\|(.*)/g

const singles = {
    '!s': { command: 'stop' },
    "/l": { command: 'left direction' },
    "/r": { command: 'right direction' },
    "/u": { command: 'up direction' },
    "/d": { command: 'down direction' },
    "/m": { command: 'triger direction' },
    "/c": { command: 'clockwise rotation' },
    "/w": { command: 'counter-clockwise rotation' },
    "na": { command: 'nop' }
}
const trigerNames = {
    "l:": "pushLeft",
    "r:": "pushRight",
    "u:": "pushUp",
    "d:": "pushDown",
    "a:": "pushAnywhere",
    "c:": "rotated",
    "t:": "tick",
}

const parseCommand = (com) => {
    if (functionRegex.test(com)) {
        const command = com.split(functionRegex)
        return {
            command: 'function definition',
            name: command[1],
            inputs: command[2].split(','),
            code: command[3].split(',').map(parseCommand)
        }
    }

    if (trigers.test(com)) {
        const command = com.split(trigers)
        const input = parseCommand(command[2])
        input.get = true
        return {
            command: 'triger',
            variant: command[1],
            func: input
        }
    }
    
    if (functionRunner.test(com)) {
        const command = com.split(functionRunner)
        return {
            command: 'function runner',
            name: command[2],
            inputs: command[1].split(',').map(parseCommand)
        }
    }
    
    if (variable.test(com)) {
        const command = com.split(variable)
        const input = parseCommand(command[2])
        input.get = true
        return {
            command: 'variable definition',
            name: command[1],
            value: input
        }
    }
    
    if (variableGetter.test(com)) {
        const command = com.split(variableGetter)
        return {
            command: 'variable value getter',
            name: command[1]
        }
    }
    
    if (ifelse.test(com)) {
        const command = com.split(ifelse)
        const input1 = parseCommand(command[1])
        input1.get = true
        const input2 = parseCommand(command[2])
        input2.get = true
        const input3 = parseCommand(command[3])
        input3.get = true
        return {
            command: 'if else',
            name: input1,
            true: input2,
            false: input3
        }
    }

    if (actions.test(com)) {
        const command = com.split(actions)
        const input = parseCommand(command[2])
        input.get = true
        return {
            command: 'action',
            variant: command[1],
            input: input
        }
    }
    
    if (data.test(com)) {
        const command = com.split(data)
        const input = parseCommand(command[2])
        input.get = true
        return {
            command: 'data reader',
            variant: command[1],
            input: input
        }
    }
    
    if (string.test(com)) {
        const command = com.split(string)
        return {
            command: 'string/number',
            value: command[1],
        }
    }
    
    return singles[com] ? singles[com] : singles['na']
}

const parser = function(rule) {
    rule = rule.replaceAll('\n', '')
    let inside = false
    let commands = ['']
    for (let idx = 0, char = ''; idx < rule.length + 1; char = rule[idx++]) {
        if (char === ',' && !inside) {
            commands.push('')
            continue
        }
        commands[commands.length-1] += char
        if (char === '"' || char === '(' || char === '{') {
            inside = true
            continue
        }
        if (char === '"' || char === ')' || char === '}') {
            inside = false
            continue
        }
    }
    let retVal = {
        vars: {
            cdir: 0,
            cnam: 'none'
        },
        funcs: {
            imp: {
                inputs: ['module'],
                commands: { 
                    command: 'call', 
                    func: 'importer', 
                    args: [
                        {
                            command: 'variable value getter',
                            name: 'module'
                        }
                    ] 
                }
            },
            pos: {
                inputs: ['x', 'y'],
                commands: { 
                    command: 'call', 
                    func: 'position callculator' ,
                    args: [
                        {
                            command: 'variable value getter',
                            name: 'x'
                        },
                        {
                            command: 'variable value getter',
                            name: 'y'
                        }
                    ] 
                }
            },
            call: {
                inputs: ['function'],
                commands: { 
                    command: 'call', 
                    func: {
                        command: 'variable value getter',
                        name: 'function'
                    },
                    args: [
                        {
                            command: 'variable value getter',
                            name: '[funcArgs]'
                        }
                    ]
                }
            },
            newNeighbor: {
                inputs: ['location', 'type'],
                commands: { 
                    command: 'call', 
                    func: 'create new neighbor',
                    args: [
                        {
                            command: 'variable value getter',
                            name: 'location'
                        },
                        {
                            command: 'variable value getter',
                            name: 'type'
                        }
                    ]
                }
            }
        },
        trigers: {
            tick: [],
            pushUp: [],
            pushDown: [],
            pushLeft: [],
            pushRight: [],
            pushAnywhere: [],
            rotated: []
        },
        commands: []
    }
    retVal.commands = commands = commands.map(command => {
        command = parseCommand(command)
        if (command.command === 'triger') {
            retVal.trigers[trigerNames[command.variant]].push(command.func)
        }
        return command
    })

    return retVal
}

module.exports = parser


class cellParser {
    constructor (runtime) {
        // Extension stuff
        this.runtime = runtime;
    }

    getInfo () {
        return {
            id: 'cellparser',
            name: 'Gam Cell Rule Parser',
            color1: '#4576b4d',
            blocks: [
                {
                    opcode: 'parsetextcodeintojson',
                    blockType: "reporter",
                    text: "parse text code [text] into json data",
                    arguments: {
                        text: {
                            type: "string",
                            defaultValue: "$(\"relative moveable vertically\")imp,tick$=(){u>/u,/u},t:$()tick"
                        }
                    }
                }
            ]
        };
    };
    
    // Code for blocks go here
    
    parsetextcodeintojson({text}) {
        return JSON.stringify(parser(text))
    }
};



(function() {
    var extensionClass = cellParser;
    if (typeof window === "undefined" || !window.vm) {
        Scratch.extensions.register(new extensionClass());
    } else {
        var extensionInstance = new extensionClass(window.vm.extensionManager.runtime);
        var serviceName = window.vm.extensionManager._registerInternalExtension(extensionInstance);
        window.vm.extensionManager._loadedExtensions.set(extensionInstance.getInfo().id, serviceName);
    };
})()